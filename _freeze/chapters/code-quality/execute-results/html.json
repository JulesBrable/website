{
  "hash": "ba09a038677600d993d164299fded89a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Améliorer la qualité de son code\"\ndescription: |\n  Présentation des standards permettant de produire du code lisible et maintenable, et d'outils pour faciliter leur adoption.\nimage: images/snake.png\norder: 2\nhref: chapters/code-quality.html\n---\n\n<details>\n<summary>\nDérouler les _slides_ ci-dessous ou [cliquer ici](https://ensae-reproductibilite.github.io/slides/#/qualité-du-code)\npour afficher les slides en plein écran.\n</summary>\n\n\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode yaml code-with-copy\"><code class=\"sourceCode yaml\"></code><button title=\"Copy to Clipboard\" class=\"code-copy-button\"><i class=\"bi\"></i></button></pre><iframe class=\"sourceCode yaml code-with-copy\" src=\"https://ensae-reproductibilite.github.io/slides/#/qualité-du-code\"></iframe></div>\n\n</details>\n\nCe chapitre constitue une introduction à la question de la qualité du code, \npremier niveau dans l'échelle des bonnes pratiques. Celui-ci présente\nles enjeux de la qualité du code, les principes généraux pour améliorer\ncelui-ci et quelques outils ou gestes faciles à mettre en œuvre\npour améliorer la qualité du code. Ceux-ci sont approfondis dans\nl'[application fil rouge](/chapters/application.qmd). \n \n\n# Introduction\n\n![Image empruntée à la page \"Les joies du code\"](/berk.png){fig-align=\"center\"}\n\n## L'enjeu d'un code lisible et maintenable\n\n> _\"The code is read much more often than it is written.\"_\n>\n> Guido Van Rossum[^1]\n\n[^1]: Guido Van Rossum est le créateur de {{< fa brands python >}}, c'est donc quelqu'un qu'il est pertinent d'écouter.\n\nLorsqu'on s'initie à la pratique de la *data science*, il est assez naturel de voir le code d'une manière très fonctionnelle : je veux réaliser une tâche donnée — par exemple un algorithme de classification — et je vais donc assembler dans un *notebook* des bouts de code, souvent trouvés sur internet, jusqu'à obtenir un projet qui réalise la tâche voulue. La structure du projet importe assez peu, tant qu'elle permet d'importer correctement les données nécessaires à la tâche en question.\n\nSi cette approche flexible et minimaliste fonctionne très bien lors de la phase d'apprentissage, il est malgré tout indispensable de s'en détacher progressivement à mesure que l'on progresse et que l'on est amené à réaliser des projets plus professionnels ou bien à intégrer des projets collaboratifs. Autrement, on risque de __produire un code complexe à reprendre et à faire évoluer, ce qui pourrait conduire inévitablement à son abandon__.\n\nEn particulier, il est important de proposer, parmi les multiples manières de résoudre un problème informatique, une solution qui soit intelligible par d'autres personnes parlant le même langage. Le code est en effet lu bien plus souvent qu'il n'est écrit, c'est donc avant tout un __outil de communication__. De même, la maintenance d'un code demande généralement beaucoup plus de moyens que sa phase de développement initial. Il est donc important de penser en amont la qualité de son code et la structure de son projet de sorte à le rendre maintenable dans le temps.\n\nAfin de faciliter la communication et réduire la douleur d'avoir à faire évoluer un code obscur, des tentatives plus ou moins institutionnalisées de définir des conventions ont émergé. Ces conventions dépendent naturellement du langage utilisé, mais les principes sous-jacents s'appliquent de manière universelle à tout projet basé sur du code.\n\n\n## De l'importance de suivre les conventions\n\n`Python` est un langage très __lisible__.\nAvec un peu d’effort sur le nom des objets,\nsur la gestion des dépendances et sur la structure du programme,\non peut très bien comprendre un script sans avoir besoin de l’exécuter.\nC'est l'une des principales forces du langage `Python` qui permet ainsi\nune acquisition rapide des bases et facilite l'appropriation d'un script.\n\nLa communauté `Python` a abouti à un certain nombre de normes,\ndites `PEP` (_Python Enhancement Proposal_),\nqui constituent un standard dans l’écosystème Python.\nLes deux normes les plus connues sont :\n\n- la __norme [`PEP8`](https://peps.python.org/pep-0008/)__ qui définit un certain nombre de conventions\nrelatives au code ;\n- la __norme [`PEP257`](https://peps.python.org/pep-0257/)__ consacrée à la documentation (_docstrings_).\n\nCes conventions vont au-delà de la syntaxe. Un certain nombre de standards\nd'organisation d'un projet ont émergé, qui seront abordées\ndans le [prochain chapitre](/chapters/projects-architecture.html). \n\n::: {.callout-note collapse=\"true\"}\n## Comparaison avec {{< fa brands r-project >}} \n\nDans l'univers {{< fa brands r-project >}}, la formalisation\na été moins organisée. Ce langage est plus permissif que `Python`\nsur certains aspects[^2]. Néanmoins, des standards ont émergé récemment, à travers\nun certain nombre de _style guides_ dont les plus connus\nsont le\n[_tidyverse style guide_](https://style.tidyverse.org/googl) et le\n[_google style guide_](https://google.github.io/styleguide/Rguide.html), [MLR style guide](https://github.com/mlr-org/mlr3/wiki/Style-Guide#theoretical-style-guide)...\n\nPour aller plus loin sur {{< fa brands r-project >}}:\n\n* La formation Insee [aux bonnes pratiques avec `Git` et {{< fa brands r-project >}}](https://inseefrlab.github.io/formation-bonnes-pratiques-git-R/) dont le parcours est très proche de celui de ce cours ; \n* Des éléments complémentaires dans la [documentation collaborative `utilitR`](https://www.book.utilitr.org/02_bonnes_pratiques/01-qualite-code) ;\n* [Ce post](https://blog.r-hub.io/2022/03/21/code-style/) qui pointe vers\nun certain nombre de ressources sur le sujet.\n:::\n\n[^2]: Par exemple, en {{< fa brands r-project >}}, il est possible d'utiliser `<-` ou `=`\npour l'assignation,\non ne recontre pas d'erreur en cas de mauvaise indentation...\n\nCes conventions sont arbitraires, dans une certaine mesure. Il est tout à fait\npossible de trouver certaines conventions moins esthétiques que d'autres. \n\nCes conventions ne sont pas non plus immuables : les langages et leurs usages\névoluent, ce qui nécessite de mettre à jour les conventions. Cependant,\nadopter dans la mesure du possible certains des réflexes préconisés par ces\nconventions devrait améliorer la capacité à être compris par la communauté,\naugmenter les chances de \nbénéficier d'apport de celle-ci pour adapter le code, mais aussi réduire la \ndifficulté à faire évoluer un code.\n\nIl existe beaucoup de philosophies différentes sur le style de codage et,\nen fait, le plus important est\nla __cohérence__ :\nsi on choisit une convention, par exemple _snake case_ (`toto_a_la_plage`) plutôt que\n_camel case_ (`totoALaPlage`), le mieux est de s'y tenir. \n\n\n# Principe 1️⃣ : Adopter les standards communautaires\n\nDans la lignée de la vision des bonnes pratiques comme\ncontinuum proposée en [introduction](/chapters/introduction.qmd), il n'est pas nécessairement souhaitable d'appliquer toutes les recommandations présentées dans ce chapitre à chaque projet. Sur certains projets, le coût marginal\nd'adopter certaines pratiques peut excéder les bénéfices induits. \nNous recommandons plutôt de voir ces bonnes pratiques comme de bonnes habitudes à acquérir en opérant un va-et-vient régulier entre la pratique et la théorie. Les outils\nque nous allons proposer seront là pour accélérer la mise en œuvre des bonnes pratiques.\n\nLes éléments exposés dans ce chapitre n'ont pas vocation à être exhaustifs.\nIls visent à pointer vers quelques ressources utiles tout en proposant des conseils pratiques.\nL'apprentissage par cœur de ces règles ou\nfaire des aller-retour en continu entre le code\net les manuels de règles \nserait quelques\npeu rébarbatif.\n\nPour faire le parallèle avec\nle langage naturel, on n'a pas toujours le bescherelle \nou le dictionnaire sous les yeux. Les éditeurs de \ntexte ou les smartphones embarquent des correcteurs\northographiques qui identifient, voire corrigent\ndirectement le texte écrit. \n\n## Un bon IDE, un premier pas vers la qualité\n\nSans les outils automatisés de mise en forme du code, l'adoption des bonnes\npratiques serait coûteuse en temps et donc difficile à mettre en œuvre\nau quotidien. Ces outils, que ce soit par le biais de diagnostics ou de\nmise aux normes automatisée du code\nrendent de précieux services. Adopter les standards minimaux de qualité\nest plus ou moins instantané et économise un temps précieux dans la vie\nd'un projet de _data science_. C'est un préalable indispensable à la \nmise en production, sur laquelle nous reviendrons ultérieurement. \n\n\nLe premier pas vers les bonnes pratiques est d'adopter un environnement de développement\nadapté. `VSCode` est un très bon environnement comme nous le découvrirons\ndans la [partie pratique](/chapters/application.qmd). Il propose tous les\noutils d'autocomplétion et de diagnostics usuels (contrairement \nà `Jupyter`) et propose une grande gamme d'extensions pour enrichir\nles fonctionnalités de l'IDE de manière contributive :\n\n![Exemple de diagnostics et d'actions proposés par `VSCode`](https://code.visualstudio.com/assets/docs/python/editing/packageAbbreviations.gif)\n\nNéanmoins, les outils de détection de code au niveau des IDE\nne suffisent pas. En effet, ils nécessitent une composante manuelle\nqui peut être chronophage et ainsi pénible à appliquer\nrégulièrement. Heureusement, il existe des outils automatisés de diagnostics\net de mise en forme. \n\n\n\n### Les outils automatisés pour le diagnostic et la mise en forme du code \n\n`Python` étant l'outil de travail principal de milliers de \n_data-scientists_, un certain nombre d'outils ont vu le jour\npour réduire le temps nécessaire pour créer un projet ou disposer\nd'un code fonctionnel. Ces outils permettent un gros gain de productivité,\nréduisent le temps passé à effectuer des tâches rébarbatives et améliorent\nla qualité d'un projet en offrant des diagnostics, voire des correctifs\nà des codes perfectibles. \n\nLes deux principaux types d'outils sont les suivants :\n\n1. **_Linter_** : programme qui vérifie que le code est __formellement__ conforme à un certain _guidestyle_\n    + signale des problèmes formels, sans corriger \n2. **_Formatter_** : programme qui reformate un code pour le rendre conforme à un certain _guidestyle_\n    + modifie directement le code\n\n\n::: {.callout-tip collapse=\"true\"}\n## Exemples\n\n- Exemples d’erreurs repérées par un _linter_ : \n    + lignes de code trop longues ou mal indentées, parenthèses non équilibrées, noms de fonctions mal construits…\n- Exemples d’erreurs __non__ repérées par un _linter_ :\n    + fonctions mal utilisées, arguments mal spécifiés, structure du code incohérente, code insuffisamment documenté…\n:::\n\n\n### Les _linters_ pour comprendre les mauvaises pratiques appliquées\n\nLes _linters_ sont des outils qui permettent d'évaluer la qualité du \ncode et son risque de provoquer une erreur (explicite ou silencieuse).\n\nVoici quelques exemples de problèmes que peuvent rencontrer les \n`linters`:\n\n* les variables sont utilisées mais n'existent pas (erreur)\n* les variables inutilisées (inutiles)\n* la mauvaise organisation du code (risque d'erreur)\n* le non-respect des bonnes pratiques d'écriture de code\n* les erreurs de syntaxe (par exemple les coquilles)\n    \nLa plupart des logiciels de développement embarquent des fonctionnalités\nde diagnostic (voire de suggestion de correctif). Il faut parfois\nles paramétrer dans les options (ils sont désactivés pour ne pas\neffrayer l'utilisateur avec des croix rouges partout).\nNéanmoins, si on n'a pas appliqué les correctifs\nau fil de l'eau la masse des modifications à mettre en \nœuvre peut être effrayante. \n\nEn `Python`, les deux principaux _linters_\nsont [`PyLint`](https://pylint.readthedocs.io/en/latest/) et\n[`Flake8`](https://flake8.pycqa.org/en/latest/). \nDans les exercices, nous proposons d'utiliser `PyLint` qui est\npratique et pédagogique. Celui-ci s'utilise en ligne de commande,\nde la manière suivante :\n\n```{.bash}\npip install pylint\npylint monscript.py #pour un fichier\npylint src #pour tous les fichiers du dossier src\n```\n\n\n::: {.callout-tip collapse=\"true\"}\n\nL'un des intérêts d'utiliser `PyLint` est qu'on obtient une note,\nce qui est assez instructif. Nous l'utiliserons dans l'application\nfil rouge pour comprendre la manière dont chaque étape améliore\nla qualité du code. \n\nIl est possible de mettre en œuvre des [_pre commit hooks_](https://pylint.readthedocs.io/en/latest/user_guide/installation/pre-commit-integration.html) qui empêchent un\n_commit_ n'ayant pas une note minimale. \n\n:::\n\n### Les _formatters_ pour nettoyer en masse ses scripts \n\nLe _formatter_ modifie directement le code. On peut\nfaire un parallèle avec le correcteur orthographique.\nCet outil peut\ndonc induire un changement substantiel du script\nafin de le rendre plus lisible.\n\nLe _formater_ le plus utilisé\n\nest [`Black`](https://black.readthedocs.io/en/stable/). \nRécemment, [`Ruff`](https://github.com/astral-sh/ruff),\nqui est à la fois un _linter_ et un _formatter_\na émergé pour intégrer à `Black` des diagnostics\nsupplémentaires, issus d'autres _packages_.\n\n::: {.callout-note collapse=\"true\"}\n\nPour signaler sur `Github`\nla qualité d'un projet utilisant `Black`, il est possible\nd'ajouter un badge dans le `README`:\n\n[![](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)\n\n:::\n\n\nIl est assez instructif de regarder\nle code modifié par les outils pour comprendre et corriger certains problèmes dans sa manière de développer. \nPar exemple, à la lecture de ce chapitre, vous allez certainement retenir en particulier certaines règles qui tranchent avec vos pratiques actuelles. Vous pouvez alors essayer d'appliquer ces nouvelles règles pendant un certain temps puis, lorsque celles-ci seront devenues naturelles, revenir à ce guide et appliquer le processus à nouveau. En procédant ainsi de manière incrémentale, vous améliorerez progressivement la qualité de vos projets sans avoir l'impression de passer trop de temps sur des micro-détails, au détriment des objectifs globaux du projet.\n\n## Le partage, une démarche favorable à la qualité du code\n\n### L'_opensource_ comme moyen pour améliorer la qualité\n\nEn ouvrant son code sur des forges _opensource_ (cf. [chapitre `Git`](/chapters/git.qmd)), il est possible de recevoir\ndes suggestions voire, des contributions de ré-utilisateurs\ndu code. Cependant, les vertus de l'ouverture vont au-delà.\nEn effet, l'ouverture se traduit généralement par des codes de \nmeilleure qualité, mieux documentés pour pouvoir être réutilisés\nou ayant simplement bénéficié d'une attention accrue sur la qualité\npour ne pas paraître ridicule. Même en l'absence de retour de (ré)utilisateurs\ndu code, le partage de code améliore la qualité des projets. \n\n### La revue de code\n\nLa revue de code s'inspire de la méthode du _peer reviewing_ du monde académique\npour améliorer la qualité du code `Python`. Dans une revue de code, \nle code écrit par une personne est relu et évalué par un ou plusieurs autres développeurs\nafin d'identifier les erreurs et les améliorations possibles.\nCette pratique permet de détecter les erreurs avant qu'elles ne deviennent des problèmes majeurs,\nd'assurer une cohérence dans le code, de garantir le respect des bonnes pratiques\nmais aussi d'améliorer la qualité du code en identifiant les parties du code qui peuvent être simplifiées, optimisées ou refactorisées pour en améliorer la lisibilité et la maintenabilité.\n\nUn autre avantage de cette approche est qu'elle permet le \npartage de connaissances entre des personnes expérimentées et des personnes\nplus débutantes ce qui permet à ces dernières de monter en compétence.\n`Github` {{< fa brands github >}} et `Gitlab` {{< fa brands gitlab >}}\nproposent des fonctionnalités très pratiques\npour la revue de code : discussions, suggestions de modifications...\n\n\n# Principe 2️⃣ : favoriser une structure modulaire\n\n## Objectifs\n\n- Favoriser la __concision__ pour réduire le risque d'erreur\net rendre la démarche plus claire ;\n- Améliorer la __lisibilité__ ce qui est indispensable pour\nrendre la démarche intelligible par d'autres mais aussi pour soi, lorsqu'on\nreprend un code écrit il y a quelques temps ;\n- Limiter la __redondance__ ce qui permet de simplifier\nun code (paradigme du _don't repeat yourself_) ;\n- Limite les risques d’__erreurs liées aux copier/coller__\n\n## Avantages des fonctions\n\nLes fonctions ont de nombreux avantages par rapport à de longs\nscripts :\n\n- Limite les risques d'erreurs liés aux copier/coller\n- Rend le code plus lisible et plus compact\n- Un seul endroit du code à modifier lorsqu'on souhaite modifier le traitement\n- Facilite la réutilisation et la documentation du code !\n\n::: {.callout-important}\n## Règle d'or\n\nIl faut utiliser une [**fonction**]{.red2} dès qu'on utilise une même\nportion de code plus de deux fois ([**_don't repeat yourself_ (DRY)**]{.red2})\n:::\n\n\n::: {.callout-tip}\n## Règles pour écrire des fonctions **pertinentes**\n\n- Une tâche = une fonction\n- Une tâche complexe = un enchaînement de fonctions réalisant chacune une tâche simple\n- Limiter l'utilisation de variables globales\n\n:::\n\nEn ce qui concerne l'installation des packages, nous allons voir\ndans les parties [Structure de code](/chapters/projects-architecture.html) et [Portabilité](/chapters/portability.qmd)\nqu'il ne faut pas\ngérer ceci dans le script mais dans un élément à part, relatif à l'environnement \nd'exécution du projet[^environnement]. De même, ces parties présenteront\ndes conseils pratiques sur la gestion des jetons d'accès à des API ou bases de données\nqui ne __doivent jamais être inscrites dans un code__. \n\n[^environnement]: Nous présenterons les deux approches principales en `Python`,\n        leurs points commun et les points par lesquels ils diffèrent : \n        les environnements virtuels (gérés par un fichier `requirements.txt`)\n        et les environnements conda (gérés par un fichier `environment.yml`)\n\n\nLes scripts trop longs ne sont pas une bonne pratique. Il est préférable\nde diviser l'ensemble des scripts exécutant une\nchaîne de production en _\"monades\"_, c'est-à-dire en petites unités\ncohérentes. Les fonctions sont un outil privilégié pour cela\n(en plus de limiter la redondance, et d'être un outil privilégié\npour documenter un code).\n\n\n::: {.callout-caution collapse=\"true\"}\n## Exemple: privilégier les _list comprehensions_\n\nEn `Python`, il est recommandé de privilégier\nles _list comprehensions_ à l'utilisation de boucles\n`for` indentées. Ces dernières sont en général moins\nefficaces et surtout impliquent un nombre important de \nligne de codes là où les compréhensions de listes sont\nbeaucoup plus concises\n\n```python\nliste_nombres = range(10)\n\n# très mauvais\ny = []\nfor x in liste_nombres:\n    if x % 2 == 0:\n        y.append(x*x)\n\n# mieux\ny = [x*x for x in liste_nombres if x % 2 == 0]\n```\n\n\n:::\n\n\n### Conseils pour la programmation\n\nDans le monde de la programmation en `Python`, il existe deux paradigmes\ndifférents :\n\n* La __programmation fonctionnelle__ est une approche qui construit un \ncode en enchaînant des fonctions, c'est-à-dire des opérations plus ou\nmoins standardisées ; \n* La __programmation orientée objet (POO)__ consiste\nà construire son code en définissant des objets\nd'une certaine _classe_ ayant des\n_attributs_ (les caractéristiques intrinsèques de l'objet)\net sur lequel on effectue des opérations _ad hoc_ par le biais\nde _méthodes_ qui encapsulent des opérations propres à\nchaque classe. \n\n\n<details>\n\n<summary>\nExemple de comparaison des deux paradigmes\n</summary>\n\nMerci _ChatGPT_ pour l'exemple :\n\n::: {#38e975f3 .cell execution_count=1}\n``` {.python .cell-code}\nclass AverageCalculator:\n    def __init__(self, numbers):\n        self.numbers = numbers\n\n    def calculate_average(self):\n        return sum(self.numbers) / len(self.numbers)\n\n# Utilisation\ncalculator = AverageCalculator([1, 2, 3, 4, 5])\nprint(\"Moyenne (POO):\", calculator.calculate_average())\n\ndef calculate_average(numbers):\n    return sum(numbers) / len(numbers)\n\n# Utilisation\nnumbers = [1, 2, 3, 4, 5]\nprint(\"Moyenne (PF):\", calculate_average(numbers))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMoyenne (POO): 3.0\nMoyenne (PF): 3.0\n```\n:::\n:::\n\n\n</details>\n\nLa programmation fonctionnelle est plus intuitive que la\nPOO et permet souvent de développer du code plus\nrapidement. La POO est une approche plus formaliste.\nCelle-ci est intéressante lorsqu'une fonction doit\ns'adapter au type d'objet en entrée (par exemple aller chercher des\npoids différents selon le type de modèle [`Pytorch`](https://pytorch.org/vision/0.9/models.html)).\nCela évite les codes _spaghetti_ 🍝 inutilement complexes qui sont impossibles à débugger.\n\nNéanmoins, il convient d'être pragmatique. La programmation orientée objet peut être\nplus complexe à mettre en œuvre que la programmation fonctionnelle. Dans de \nnombreuses situations, cette dernière, si elle est bien faite, suffit largement. \nIl est utile lorsqu'on développe dans le cadre d'un projet important d'adopter\nune approche dite de __programmation défensive__. Il s'agit d'un principe\nde précaution dans le paradigme de la programmation fonctionnelle qui vise\nà limiter les\nsituations imprévues en étant capable\nde gérer, par exemple, un argument d'une fonction inattendu ou un objet\nà la structure différente de celle pour lequel le code a été pensé. \n\n::: {.callout-note}\n\n## Le code spaghetti\n\nLe code `spaghetti` est un style d'écriture qui favorise l'apparition du syndrome du plat de spaghettis : \nun code impossible à démêler parce qu'il fait un usage excessif de conditions, d'exceptions en tous sens, de gestion des événements complexes. Il devient quasi impossible de savoir quelles ont été les conditions à l'origine de telle ou telle erreur sans exécuter ligne à ligne (et celles-ci sont excessivement nombreuses du fait de mauvaises pratiques de programmation) le programme. \n\nEn fait, la programmation spaghetti qualifie tout ce qui ne permet pas de déterminer le qui, le quoi et le comment. Le code est donc plus long à mettre à jour car cela nécessite de remonter un à un le fil des renvois.\n\n:::\n\n::: {.callout-tip collapse=\"true\"}\n\n## Un exemple progressif pour comprendre\n\n💡 Supposons qu'on dispose d'une table de données qui utilise le code `−99` pour représenter les valeurs manquantes.\nOn désire remplacer l'ensemble des `−99` par des `NA`.\n\nVoici un code `Python` qui permet de se placer dans ce cas qui, malheureusement,\narrive fréquemment.\n\n```python\n# On fixe la racine pour être sûr de tous avoir le même dataset\nnp.random.seed(1234)\n\n# On créé un dataframe\na = np.random.randint(1, 10, size = (5,6))\ndf = np.insert(\n    a,\n    np.random.choice(len(a), size=6),\n    -99,\n)\ndf = pd.DataFrame(df.reshape((6,6)), columns=[chr(x) for x in range(97, 103)])\n```\n\n\nUn premier jet de code pourrait prendre la forme suivante :\n\n```python\n# Dupliquer les données\ndf2 = df.copy()\n# Remplacer les -99 par des NA\ndf2.loc[df2['a'] == -99,'a'] = np.nan\ndf2.loc[df2['b'] == -99,'b'] = np.nan\ndf2.loc[df2['c'] == -99,'c'] = np.nan\ndf2.loc[df2['d'] == -99,'d'] = np.nan\ndf2.loc[df2['e'] == -98,'e'] = np.nan\ndf2.loc[df2['f'] == -99,'e'] = np.nan\n```\n\nQuelles sont les choses qui vous dérangent dans le code ci-dessus ?\n\n<details>\n<summary>\nIndice 💡 Regardez précisément le code et le `DataFrame`, notamment les colonnes `e` et `g`.\n</summary>\nIl y a deux erreurs, difficiles à détecter:\n\n- `df2.loc[df2['e'] == -98,'e'] = np.nan`: une erreur de copier-coller sur la valeur de l'erreur ;\n- `df2.loc[df2['f'] == -99,'e'] = np.nan`: une erreur de copier-coller sur les colonnes en question\n</details>\n\nOn peut noter au moins deux trois :\n\n* Le code est long et répétitif, ce qui nuit à sa lisibilité ;\n* Le code est très dépendant de la structure des données (nom et nombre de colonnes) et doit être adapté dès que celle-ci évolue ;\n* On a introduit des erreurs humaines dans le code, difficiles à détecter. \n\nOn voit dans la première version de notre code qu'il y a une structure commune à toutes nos lignes de la forme `.[. == -99] = np.nan`. Cette structure va servir de base à notre fonction, en vue de généraliser le traitement que nous voulons faire.\n\n```python\ndef fix_missing(x: pd.Series):\n    x[x == -99] = np.nan\n    return x\n\ndf2 = df.copy()\ndf2['a'] = fix_missing(df['a'])\ndf2['b'] = fix_missing(df['b'])\ndf2['c'] = fix_missing(df['c'])\ndf2['d'] = fix_missing(df['d'])\ndf2['e'] = fix_missing(df['e'])\ndf2['f'] = fix_missing(df['f'])\n```\n\nCette seconde version du code est meilleure que la première version, car on a réglé le problème d'erreur humaine (il n'est plus possible de taper `-98` au lieu de `-99`).\n\n<details>\n<summary>\nMais voyez-vous le problème qui persiste ?\n</summary>\n\nLe code reste long et répétitif, et n'élimine pas encore toute possibilité d'erreur, car il est toujours possible de se tromper dans le nom des variables. \n</details>\n\nLa prochaine étape consiste à éliminer ce risque d'erreur en combinant deux fonctions (ce qu'on appelle la combinaison de fonctions).\n\nLa première fonction `fix_missing()` sert à régler le problème sur un vecteur. La seconde généralisera ce procédé à toutes les colonnes. Comme `Pandas` permet une approche vectorielle, il est fréquent de construire des fonctions sur des vecteurs et les appliquer ensuite à plusieurs colonnes.\n\n\n```python\ndef fix_missing(x: pd.Series):\n    x[x == -99] = np.nan\n    return x\n\ndf2 = df.copy()\ndf2 = df2.apply(fix_missing)\n```\n\nCette troisième version du code a plusieurs avantages sur les deux autres versions :\n\n1. Elle est plus concise et plus lisible ;\n2. Si on a un changement de code pour les valeurs manquantes, il suffit de le mettre à un seul endroit ;\n3. Elle fonctionne quel que soit le nombre de colonnes et le nom des colonnes ;\n4. On ne peut pas traiter une colonne différemment des autres par erreur.\n\nDe plus, le code est facilement généralisable.\n\nPar exemple, à partir de la même structure, écrire le code qui permet de ne traiter que les colonnes *a*,*b* et *e*\nne demande pas beaucoup d'énergie.\n\n\n```python\ndf2 = df.copy()\ndf2[['a','b','e']] = df2[['a','b','e']].apply(fix_missing)\n```\n:::\n\nUn certain nombre de conseils sont présents dans le [Hitchhiker's Guide to Python](https://docs.python-guide.org/writing/style/)\nqui vise à faire connaître les préceptes du _\"Zen of Python\"_ (PEP 20).\n[Ce post de blog](https://towardsdatascience.com/the-zen-of-python-a-guide-to-pythons-design-principles-93f3f76d088a) illustre quelques uns\nde ces principes avec des exemples.\n\n::: {.callout-note collapse=\"true\"}\n## Le _Zen de Python_\n\nLe _\"Zen de Python\"_ est une collection de principes pour la programmation en `Python`, écrite par Tim Peters en 2004\nsous la forme d'aphorismes. Ceux-ci\nmettent en lumière la philosophie de conception du langage `Python`.\n\nVous pouvez retrouver ces conseils dans `Python` en \ntapant le code suivant:\n\n:::: {.python}\n\n```python\nimport this\n```\n\n```\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n```\n\n::::\n\n:::\n\n\n\n# Principe 3️⃣ : (auto)documenter son code\n\nUn code écrit avec des __noms de variables et de fonctions explicites__ est autant,\nvoire plus, informatif que les commentaires qui l’accompagnent.\nC’est pourquoi il est essentiel de respecter des conventions, et de s'y tenir,\npour le\nchoix des noms des objets afin d’assurer la lisibilité des programmes.\n\nIl est recommandé de privilégier l'__autodocumentation__\nà la multiplication de commentaires dans un document. Trop de commentaires fait que\nceux-ci ne seront\njamais lus. Ils risquent d'ailleurs de ne pas être actualisés en même temps que le code\nqu'ils accompagnent, ce qui est une source d'erreur potentielle.  \nUne documentation est inutile si elle décrit ce qui est intelligible\npar ailleurs en lisant le code : il est donc important\nde documenter le pourquoi plutôt que le comment. \n\nEn résumé,\nles deux grands principes de la documentation au sein d'un script sont les suivants :\n\n- Il est préférable de __documenter le pourquoi plutôt que le comment__. Le _\"comment\"_ devrait\nêtre compréhensible à la lecture du code ;\n- Privilégier l'autodocumentation via des __nommages pertinents__.\n\n\n::: {.callout-tip}\n## Comment bien documenter un script ?\n\n- **Minimum** 🚦 : commentaire au début du script pour décrire ce qu'il fait\n- **Bien** 👍 : commenter les parties \"délicates\" du code\n- **Idéal** 💪 : documenter ses fonctions avec la syntaxe des `docstrings`.\n\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Le _type hinting_, un élément d'autodocumentation\n\n`Python` propose une fonctionalité assez plaisante qui est\nle _`type hinting`_\n([doc officielle](https://docs.python.org/3/library/typing.html)\net [tutoriel sur realpython.com](https://realpython.com/lessons/type-hinting/)).\n\nCette approche permet d'indiquer le type d'argument attendu par une fonction\net celui qui sera renvoyé par la fonction.\nPar exemple, la personne ayant écrit la fonction suivante \n\n```python\ndef calcul_moyenne(df: pd.DataFrame, col : str = \"y\") -> pd.DataFrame:\n    return df[col].mean()\n```\n\npropose d'utiliser deux types d'inputs (un `DataFrame Pandas` et une chaine de caractère)\net indique qu'elle renverra un `DataFrame Pandas`.\nA noter que c'est indicatif, non contraignant.\nEn effet, le code ci-dessus fonctionnera si on fournit en argument `col` une liste puisque `Pandas` sait gérer cela à l'étape `df[col].mean()`.\n\nLe _type hinting_ est un élément d'autodocumentation puisque grâce à ces _hints_ le code\nsuffit à faire comprendre la volonté de la personne l'ayant écrit. \n:::\n\n\nLa documentation vise à présenter la démarche générale, éventuellement\nà travers des exemples, mais aussi à expliciter certains éléments\ndu code (une opération qui n'est pas évidente, des arguments de fonction, etc.). \nLa documentation se mélange donc aux instructions visant à être exécutées\nmais s'en distingue. Ces principes sont hérités du paradigme de la \n**\"programmation lettrée\"** (_Literate programming_) dont l'un des \navocats était Donald Knuth. \n\n\n> _\"Je crois que le temps est venu pour une amélioration significative de la documentation des programmes, et que le meilleur moyen d'y arriver est de considérer les programmes comme des œuvres littéraires. D'où mon titre, « programmation lettrée »._\n>\n> _Nous devons changer notre attitude traditionnelle envers la construction des programmes : au lieu de considérer que notre tâche principale est de dire à un ordinateur ce qu'il doit faire, appliquons-nous plutôt à expliquer à des êtres humains ce que nous voulons que l'ordinateur fasse._\n>\n> _Celui qui pratique la programmation lettrée peut être vu comme un essayiste, qui s'attache principalement à exposer son sujet dans un style visant à l'excellence. Tel un auteur, il choisit , avec soin, le dictionnaire à la main, les noms de ses variables et en explique la signification pour chacune d'elles. Il cherche donc à obtenir un programme compréhensible parce que ses concepts sont présentés dans le meilleur ordre possible. Pour cela, il utilise un mélange de méthodes formelles et informelles qui se complètent\"_\n>\n> Donald Knuth, _Literate Programming_ ([source](https://fr.wikipedia.org/wiki/Programmation_lettr%C3%A9e))\n\nCela peut amener à distinguer deux types de documentation :\n\n1. Une documentation générale de type `Jupyter Notebook` ou `Quarto Markdown` qui \nprésente certes du code exécuté mais dont l'objet principal est de présenter\nune démarche ou des résultats ;\n2. Une documentation de la démarche plus proche du code dont l'un des \nexemples sont les _docstrings_ `Python` (ou son équivalent `R`, la documentation `Roxygen`).\n\n",
    "supporting": [
      "code-quality_files"
    ],
    "filters": [],
    "includes": {}
  }
}
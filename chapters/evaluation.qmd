---
title: "Crit√®res d'√©valuation"
description: |
  <br>
  R√©sum√© des crit√®res d'√©valuation
image: https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/kid.png
order: 10
href: chapters/evaluation.html
eval: false
echo: false
---

Evaluation en **deux parties** : 

1. **Par groupe de 3** : un **projet** √† choisir parmi les 3 parcours (MLOps, app interactive / dashboard, publication reproductible / site web) 
2. **Seul** : **revue de code**

## 1Ô∏è‚É£ Crit√®res pour la revue de code

Sur le projet d'un groupe diff√©rent du sien (attribu√© al√©atoirement) : 

- ouvrir une *pull request* de revue de code
- donner une appr√©ciation g√©n√©rale de la conformit√© du projet √† la checklist des bonnes pratiques de d√©veloppement
- sugg√©rer des pistes d'am√©lioration du projet


## 2Ô∏è‚É£ Crit√®res pour le projet

### Checklist des bonnes pratiques de d√©veloppement

- [ ] **Utilisation de `Git`**
    * Pr√©sence d'un fichier `.gitignore` adapt√© au langage et avec des r√®gles additionnelles pour respecter les bonnes pratiques de versioning
    * Travail collaboratif : utilisation des branches et des *pull requests*
- [ ]  **Pr√©sence d'un fichier `README`** pr√©sentant le projet : contexte, objectif, comment l'utiliser ?
- [ ]  **Pr√©sence d'un fichier `LICENSE`** d√©clarant la licence (_open-source_) d'exploitation du projet.
- [ ]  **Versioning des packages** : pr√©sence d'un fichier `requirements.txt` ou d'un fichier d'environnement `environment.yml` pour `conda`
- [ ]  **Bonnes pratiques de code**
    + Respect des standards communautaires : utiliser un _linter_ et/ou un _formatter_
    + Modularit√© : un script principal qui appelle des modules
- [ ] **Bonnes pratiques de structure des projets**
    + Respect des standards communautaires (`cookiecutter`)
    + Modularit√© du projet selon le mod√®le √©voqu√© dans le cours:
        * Code sur `GitHub`
        * Donn√©es sur `S3`
        * Fichiers de configuration (_secrets_, etc.) √† part

![Proposition de modularit√© du projet illustr√©e pour un projet mixte `MLOps` et _dashboard_](/workflow2.png)

### Parcours MLOps

::: {.callout-tip}
## Objectif

A partir d'un projet existant ou d'un projet type _contest_ `Kaggle`,
d√©velopper un mod√®le de ML r√©pondant √† une probl√©matique, puis le mettre en production conform√©ment aux principes du _MLOps_.
:::

**Etapes** :

- [ ] Respecter la _checklist_ des bonnes pratiques de d√©veloppement ;
- [ ] D√©velopper un mod√®le de ML qui r√©pond √† un besoin m√©tier ;
- [ ] Entra√Æner le mod√®le via validation crois√©e, avec une proc√©dure de _fine-tuning_ des hyperparam√®tres ;
- [ ] Formaliser le processus de _fine-tuning_ de mani√®re reproductible via `MLFlow` ;
- [ ] Construire une API avec `Fastapi` pour exposer le meilleur mod√®le ;
- [ ] Cr√©er une image `Docker` pour mettre √† disposition l'API ;
- [ ] D√©ployer l'API sur le `SSP Cloud` ;
- [ ] Industrialiser le d√©ploiement en mode `GitOps` avec `ArgoCD`
- [ ] G√©rer le monitoring de l'application : _logs_, _dashboard_ de suivi des performances, etc.

### Parcours dashboard / application interactive

::: {.callout-tip}
## Objectif
√† partir d'un projet existant ou d'un projet que vous construirez, d√©velopper une application interactive / un dashboard r√©pondant √† une probl√©matique m√©tier, puis la mettre en production.
:::

**Etapes** :

- [ ] Respecter la _checklist_ des bonnes pratiques de d√©veloppement
- [ ] D√©velopper une application interactive `Streamlit` ou un _dashboard_ statique avec `Quarto` r√©pondant √† une probl√©matique m√©tier
- [ ] Cr√©er une image `Docker` permettant d'exposer l'application en local
- [ ] D√©ployer l'application sur le `SSP Cloud`
- [ ] Industrialiser le d√©ploiement en mode `GitOps` avec `ArgoCD`
- [ ] G√©rer le monitoring de l'application : _logs_, m√©triques de suivi des performances, etc.

### Parcours publication reproductible

**Etapes** :

::: {.callout-tip}
## Objectif
A partir d'un projet existant ou d'un projet que vous construirez, d√©velopper une application interactive / un dashboard r√©pondant √† une probl√©matique m√©tier, puis la mettre en production.
:::

- [ ] Respecter la _checklist_ des bonnes pratiques de d√©veloppement
- [ ] R√©diger un rapport reproductible avec `Quarto` qui fasse intervenir des donn√©es, du code, de la visualisation de donn√©es, du texte, etc.
- [ ] Exposer le rapport sous la forme d'un site web via `GitHub Actions`
- [ ] Customiser le th√®me, le CSS etc. pour mettre en valeur au maximum les r√©sultats de la publication et les messages principaux
- [ ] Automatiser l'ingestion des donn√©es en entr√©e pour que le site _web_ se mette √† jour r√©guli√®rement
- [ ] Mettre en place des tests automatis√©s de v√©rification des standards de qualit√© du code (_linter_), de d√©tection de fautes d'orthographes/de grammaire, etc.
- [ ] G√©n√©rer des slides au format `quarto-revealjs` afin de pr√©senter les principaux r√©sultats de la publication, et les exposer comme une page du site


<!--------
old
--------->

```{ojs}
viewof choice = Inputs.checkbox(
    d3.group(choice_parameters, d => d.level), 
    {key: ["Indispensable üëÆ", "Bien üòé", "Excellent ü§©"], label: "Niveau souhait√©"}
)
```



```{ojs}
viewof project = Inputs.checkbox(
    d3.group(
        choice_parameters.filter(d => d.project != "all").filter(row => uniqueLevels.includes(row.level)),
        d => d.project
    ),
    {key: ["Site web statique", "API", "Application interactive", "Publication reproductible"], label: "Type d'output"}
)
```

```{ojs}
html`<div>${formatToCheckboxLists(
    liste_tableau.filter(row => uniqueLevels.includes(row.level))
)}</div>`
```



```{ojs}
viewof choice2 = Inputs.checkbox(
    d3.group(choice_parameters, d => d.level), 
    {key: uniqueLevels, label: "Niveau souhait√©"}
)
```



```{ojs}
viewof project2 = Inputs.checkbox(
    d3.group(
        choice_parameters.filter(d => d.project != "all").filter(row => uniqueLevels.includes(row.level)),
        d => d.project
    ),
    {key: ["Site web statique", "API", "Application interactive", "Publication reproductible"], label: "Type d'output"}
)
```


```{ojs}
html`<div>${
    generateFolderStructure(
        liste.filter(row => uniqueLevels2.includes(row.level))
        )
}</div>`
```

<!-----
intermediaire
---->


```{ojs}
uniqueLevels = Array.from(new Set(choice.flatMap(group => group.map(item => item.level))));
```

```{ojs}
uniqueLevels2 = Array.from(new Set(choice2.flatMap(group => group.map(item => item.level))));
```


```{ojs}
function formatToCheckboxLists(rows) {
    // Dynamically create levels based on the input data
    const levels = rows.reduce((acc, row) => {
        if (!acc[row.level]) {
            acc[row.level] = [];
        }
        acc[row.level].push(row.element);
        return acc;
    }, {});

    // Function to create HTML for checkboxes
    const createCheckboxesHtml = (elements, level) => {
        if (elements.length === 0) {
            return ''; // Skip levels with no elements
        }
        return `
            <div>
                <h3>${level}</h3>
                <ul>
                    ${elements.map(element => `<li><input type="checkbox" id="${element}" name="${level}"><label for="${element}">${element}</label></li>`).join('')}
                </ul>
            </div>
        `;
    };

    // Combine all levels into a single HTML string
    return Object.entries(levels).map(([level, elements]) => createCheckboxesHtml(elements, level)).join('');
}
```

```{ojs}
function generateFolderStructure(jsonData) {
    // Create a map to group subfiles by their parent files
    const fileMap = new Map();

    jsonData.forEach(item => {
        if (item.file) {
            // Splitting the file string into an array and trimming spaces
            const filesArray = item.file.split(',').map(file => file.trim());

            filesArray.forEach(file => {
                if (!fileMap.has(file)) {
                    fileMap.set(file, []);
                }
                if (item.subfiles) {
                    // Splitting the subfiles string into an array and trimming spaces
                    const subfilesArray = item.subfiles.split(',').map(subfile => subfile.trim());
                    fileMap.get(file).push(...subfilesArray);
                }
            });
        }
    });

    // Sort parent files
    const sortedFiles = Array.from(fileMap.keys()).sort((a, b) => a.localeCompare(b));

    let structure = "<pre><code>project\n";

    sortedFiles.forEach((file, index, array) => {
        const isLastItem = index === array.length - 1;
        const filePrefix = isLastItem ? "‚îî‚îÄ‚îÄ " : "‚îú‚îÄ‚îÄ ";
        structure += `${filePrefix}${file}\n`;

        const subfiles = fileMap.get(file);
        if (subfiles.length) {
            subfiles.forEach((subfile, subIndex, subArray) => {
                const subIsLastItem = subIndex === subArray.length - 1;
                const subPrefix = subIsLastItem ? "    ‚îî‚îÄ‚îÄ " : "    ‚îú‚îÄ‚îÄ ";
                structure += `${subPrefix}${subfile}\n`;
            });
        }
    });

    structure += "</code></pre>";
    return structure;
}
```

```{ojs}
db = DuckDBClient.of({
  input: FileAttachment("evaluation.json")
})
choice_parameters = db.query(`SELECT DISTINCT level, project FROM input`)
liste = db.query(`SELECT * FROM input`)
liste_tableau = db.query(`SELECT DISTINCT element, level FROM input`)
```

```{ojs}
import {bind} from "@observablehq/synchronized-inputs"
```